# 哈希表理论基础
    * 应用场景：一般来说哈希表都是用来快速判断一个集合是否出现集合里
    * 哈希函数：哈希函数是把传入的key映射到符号表的索引上
    * 哈希碰撞：哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法
# 常见的三种哈希结构
    * 数组：下标映射速度快，不用像map一样维护哈希表和哈希函数计算
    * 集合：基于map实现，只取key，自动去重
    * 映射：<key, value>结构
# 三种哈希结构使用场景
    * 数组：数组空间小且哈希值较小
    * 集合：数组空间大，但哈希值较小、较分散、跨度大
    * 映射：需要用key保存数值，用value保存数值的下标

# Java提供的实现类
## Set
    1. HashSet
       * 底层实现：基于HashMap实现。实际上，它使用了一个HashMap实例来存储元素，并将元素作为键，而值是一个常量对象。
       * 特性：不允许重复元素，无序（插入顺序不可预测），性能较高。
    2. LinkedHashSet
       * 底层实现：继承自HashSet，但通过维护一个双向链表来记住插入顺序。
       * 特性：除了具备HashSet的所有特性外，还能保持元素的插入顺序。
    3. TreeSet
       * 底层实现：基于红黑树的数据结构实现。
       * 特性：元素自动按升序排列，不允许重复元素。支持高效的排序操作，但是插入、删除和查找的时间复杂度为O(log n)。
## Map
    1. HashMap
        
        * 底层实现：采用哈希表数据结构。每个键值对都存储在一个Entry对象中，这些对象被分散到一个数组里，这个数组就是所谓的“桶”（bucket）。当两个不同的键计算出相同的哈希码时（即发生哈希碰撞），它们会被链接起来形成一个链表，或者在Java 8及以上版本中，在链表长度超过一定阈值后会转换成红黑树以提高查询效率。
        * 特性：允许一个null键和多个null值，非线程安全，不保证映射的顺序。
    2. LinkedHashMap
        * 底层实现：继承自HashMap，同时维护了一个双向链表记录插入顺序或访问顺序。
        * 特性：除了拥有HashMap的所有功能外，还能维护元素的插入顺序或访问顺序（最近最少使用LRU策略的基础）。
    3. TreeMap
        * 底层实现：基于红黑树的数据结构实现。
        * 特性：按键的自然顺序或者用户定义的Comparator进行排序，不允许键重复。
## 底层实现原理概述
    * 哈希函数：对于HashMap和HashSet而言，核心在于其内部使用的哈希函数，该函数负责将键映射到特定的桶索引上。一个好的哈希函数能够均匀地分布键值对，减少冲突。
    * 负载因子：这是控制哈希表扩容的一个参数，默认值通常是0.75。当哈希表中的元素数量达到容量乘以负载因子时，哈希表会自动扩容并重新哈希所有现有的条目。
    * 解决冲突：如前所述，Java 8之前的版本使用链表来处理冲突，而在Java 8及之后版本中，如果链表长度超过8并且总容量大于64，则链表会被转换成红黑树，从而提升查找效率。

